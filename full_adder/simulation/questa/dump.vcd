$date
	Tue Aug 19 21:38:15 2025
$end
$version
	Questa Intel Starter FPGA Edition Version 2024.3
$end
$timescale
	1ps
$end

$scope module tb_full_adder $end
$var reg 1 ! a $end
$var reg 1 " b $end
$var reg 1 # cin $end
$var wire 1 $ sum $end
$var wire 1 % cout $end

$scope module U0 $end
$var wire 1 & a $end
$var wire 1 ' b $end
$var wire 1 ( cin $end
$var wire 1 $ sum $end
$var wire 1 % cout $end
$var wire 1 ) gnd $end
$var wire 1 * vcc $end
$var wire 1 + unknown $end
$var tri1 1 , devclrn $end
$var tri1 1 - devpor $end
$var tri1 1 . devoe $end
$var wire 1 / sum~output_o $end
$var wire 1 0 cout~output_o $end
$var wire 1 1 cin~input_o $end
$var wire 1 2 a~input_o $end
$var wire 1 3 b~input_o $end
$var wire 1 4 U2|sum~0_combout $end
$var wire 1 5 comb~0_combout $end

$scope module auto_generated_inst $end
$var wire 1 - devpor $end
$var wire 1 , devclrn $end
$var wire 1 . devoe $end
$var wire 1 6 gnd $end
$var wire 1 7 vcc $end
$var wire 1 8 unknown $end
$var wire 1 9 ~ALTERA_ASDO_DATA1~~padout $end
$var wire 1 : ~ALTERA_FLASH_nCE_nCSO~~padout $end
$var wire 1 ; ~ALTERA_DATA0~~padout $end
$var wire 1 < ~ALTERA_ASDO_DATA1~~ibuf_o $end
$var wire 1 = ~ALTERA_FLASH_nCE_nCSO~~ibuf_o $end
$var wire 1 > ~ALTERA_DATA0~~ibuf_o $end
$upscope $end

$scope module sum~output $end
$var parameter 40 ? open_drain_output $end
$var parameter 40 @ bus_hold $end
$var parameter 144 A lpm_type $end
$var wire 1 4 i $end
$var tri1 1 * oe $end
$var tri1 1 . devoe $end
$var wire 1 B seriesterminationcontrol [15] $end
$var wire 1 C seriesterminationcontrol [14] $end
$var wire 1 D seriesterminationcontrol [13] $end
$var wire 1 E seriesterminationcontrol [12] $end
$var wire 1 F seriesterminationcontrol [11] $end
$var wire 1 G seriesterminationcontrol [10] $end
$var wire 1 H seriesterminationcontrol [9] $end
$var wire 1 I seriesterminationcontrol [8] $end
$var wire 1 J seriesterminationcontrol [7] $end
$var wire 1 K seriesterminationcontrol [6] $end
$var wire 1 L seriesterminationcontrol [5] $end
$var wire 1 M seriesterminationcontrol [4] $end
$var wire 1 N seriesterminationcontrol [3] $end
$var wire 1 O seriesterminationcontrol [2] $end
$var wire 1 P seriesterminationcontrol [1] $end
$var wire 1 Q seriesterminationcontrol [0] $end
$var wire 1 / o $end
$var wire 1 R obar $end
$var reg 1 S out_tmp $end
$var reg 1 T out_tmp_bar $end
$var reg 1 U prev_value $end
$var wire 1 V tmp $end
$var wire 1 W tmp_bar $end
$var wire 1 X tmp1 $end
$var wire 1 Y tmp1_bar $end
$upscope $end

$scope module cout~output $end
$var parameter 40 Z open_drain_output $end
$var parameter 40 [ bus_hold $end
$var parameter 144 \ lpm_type $end
$var wire 1 5 i $end
$var tri1 1 * oe $end
$var tri1 1 . devoe $end
$var wire 1 ] seriesterminationcontrol [15] $end
$var wire 1 ^ seriesterminationcontrol [14] $end
$var wire 1 _ seriesterminationcontrol [13] $end
$var wire 1 ` seriesterminationcontrol [12] $end
$var wire 1 a seriesterminationcontrol [11] $end
$var wire 1 b seriesterminationcontrol [10] $end
$var wire 1 c seriesterminationcontrol [9] $end
$var wire 1 d seriesterminationcontrol [8] $end
$var wire 1 e seriesterminationcontrol [7] $end
$var wire 1 f seriesterminationcontrol [6] $end
$var wire 1 g seriesterminationcontrol [5] $end
$var wire 1 h seriesterminationcontrol [4] $end
$var wire 1 i seriesterminationcontrol [3] $end
$var wire 1 j seriesterminationcontrol [2] $end
$var wire 1 k seriesterminationcontrol [1] $end
$var wire 1 l seriesterminationcontrol [0] $end
$var wire 1 0 o $end
$var wire 1 m obar $end
$var reg 1 n out_tmp $end
$var reg 1 o out_tmp_bar $end
$var reg 1 p prev_value $end
$var wire 1 q tmp $end
$var wire 1 r tmp_bar $end
$var wire 1 s tmp1 $end
$var wire 1 t tmp1_bar $end
$upscope $end

$scope module cin~input $end
$var parameter 40 u differential_mode $end
$var parameter 40 v bus_hold $end
$var parameter 8 w simulate_z_as $end
$var parameter 144 x lpm_type $end
$var wire 1 ( i $end
$var wire 1 ) ibar $end
$var wire 1 1 o $end
$var reg 1 y out_tmp $end
$var reg 1 z o_tmp $end
$var wire 1 { out_val $end
$var reg 1 | prev_value $end
$upscope $end

$scope module a~input $end
$var parameter 40 } differential_mode $end
$var parameter 40 ~ bus_hold $end
$var parameter 8 !! simulate_z_as $end
$var parameter 144 "! lpm_type $end
$var wire 1 & i $end
$var wire 1 ) ibar $end
$var wire 1 2 o $end
$var reg 1 #! out_tmp $end
$var reg 1 $! o_tmp $end
$var wire 1 %! out_val $end
$var reg 1 &! prev_value $end
$upscope $end

$scope module b~input $end
$var parameter 40 '! differential_mode $end
$var parameter 40 (! bus_hold $end
$var parameter 8 )! simulate_z_as $end
$var parameter 144 *! lpm_type $end
$var wire 1 ' i $end
$var wire 1 ) ibar $end
$var wire 1 3 o $end
$var reg 1 +! out_tmp $end
$var reg 1 ,! o_tmp $end
$var wire 1 -! out_val $end
$var reg 1 .! prev_value $end
$upscope $end

$scope module U2|sum~0 $end
$var parameter 16 /! lut_mask $end
$var parameter 40 0! sum_lutc_input $end
$var parameter 24 1! dont_touch $end
$var parameter 168 2! lpm_type $end
$var wire 1 1 dataa $end
$var wire 1 2 datab $end
$var wire 1 3 datac $end
$var wire 1 ) datad $end
$var wire 1 ) cin $end
$var wire 1 4 combout $end
$var wire 1 3! cout $end
$var reg 1 4! cout_tmp $end
$var reg 1 5! combout_tmp $end
$var reg 2 6! isum_lutc_input [1:0] $end
$var wire 1 7! dataa_in $end
$var wire 1 8! datab_in $end
$var wire 1 9! datac_in $end
$var wire 1 :! datad_in $end
$var wire 1 ;! cin_in $end

$scope function lut4 $end
$var reg 1 <! lut4 $end
$var reg 16 =! mask [15:0] $end
$var reg 1 >! dataa $end
$var reg 1 ?! datab $end
$var reg 1 @! datac $end
$var reg 1 A! datad $end
$upscope $end
$upscope $end

$scope module comb~0 $end
$var parameter 16 B! lut_mask $end
$var parameter 40 C! sum_lutc_input $end
$var parameter 24 D! dont_touch $end
$var parameter 168 E! lpm_type $end
$var wire 1 1 dataa $end
$var wire 1 2 datab $end
$var wire 1 3 datac $end
$var wire 1 ) datad $end
$var wire 1 ) cin $end
$var wire 1 5 combout $end
$var wire 1 F! cout $end
$var reg 1 G! cout_tmp $end
$var reg 1 H! combout_tmp $end
$var reg 2 I! isum_lutc_input [1:0] $end
$var wire 1 J! dataa_in $end
$var wire 1 K! datab_in $end
$var wire 1 L! datac_in $end
$var wire 1 M! datad_in $end
$var wire 1 N! cin_in $end

$scope function lut4 $end
$var reg 1 O! lut4 $end
$var reg 16 P! mask [15:0] $end
$var reg 1 Q! dataa $end
$var reg 1 R! datab $end
$var reg 1 S! datac $end
$var reg 1 T! datad $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
0!
0"
0#
0S
1T
0U
0n
1o
0p
0y
0z
0|
0#!
0$!
0&!
0+!
0,!
0.!
04!
05!
b0 6!
0<!
b1001011010010110 =!
0>!
0?!
0@!
0A!
0G!
0H!
b0 I!
0O!
b1110100011101000 P!
0Q!
0R!
0S!
0T!
b1001011010010110 /!
b1110100011101000 B!
b110011001100001011011000111001101100101 ?
b110011001100001011011000111001101100101 @
b11000110111100101100011011011000110111101101110011001010110100101110110011001010101111101101001011011110101111101101111011000100111010101100110 A
b110011001100001011011000111001101100101 Z
b110011001100001011011000111001101100101 [
b11000110111100101100011011011000110111101101110011001010110100101110110011001010101111101101001011011110101111101101111011000100111010101100110 \
b110011001100001011011000111001101100101 u
b110011001100001011011000111001101100101 v
b1111010 w
b11000110111100101100011011011000110111101101110011001010110100101110110011001010101111101101001011011110101111101101001011000100111010101100110 x
b110011001100001011011000111001101100101 }
b110011001100001011011000111001101100101 ~
b1111010 !!
b11000110111100101100011011011000110111101101110011001010110100101110110011001010101111101101001011011110101111101101001011000100111010101100110 "!
b110011001100001011011000111001101100101 '!
b110011001100001011011000111001101100101 (!
b1111010 )!
b11000110111100101100011011011000110111101101110011001010110100101110110011001010101111101101001011011110101111101101001011000100111010101100110 *!
b110010001100001011101000110000101100011 0!
b11011110110011001100110 1!
b11000110111100101100011011011000110111101101110011001010110100101110110011001010101111101101100011000110110010101101100011011000101111101100011011011110110110101100010 2!
b11001000110000101110100011000010